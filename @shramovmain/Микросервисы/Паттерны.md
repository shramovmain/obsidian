![[MicroservicePatternLanguage.jpg]]

*Существует три основные вида паттернов

## ==Архитектурные паттерны (паттерны микросервисов):==
Они нужны для проектирования всей программы, а не отдельных ее элементов.

1. **API Gateway**
	Это обеспечивает единую точку входа для всех сервисов, вместо того чтобы клиент напрямую общался с каждым сервисом. API-шлюз обеспечивает агрегацию, аутентификацию, кэширование и т.д.
	
	Основные реализации:
	- Spring Cloud Gateway
	- Netflix Zuul

2. **Service Registry & Discovery**
	Каждый микросервис при старте регистрирует себя в специальном реестре (**ServiceRegistry**), и другие микросервисы могут обнаруживать его по имени, а не по IP-адресу.
	
	Основные реализации:
	- Netflix Eureka

3. **CircuitBreaker:**
	Если один микросервис отваливается - CircuitBreaker "отключает" вызовы к нему, чтобы предотвратить распространение сбоя на другие микросервисы.  
	
	Основные реализации:
	- Netflix Hystix

4. **CQRS**
	Предусматривает разделение сервисов на функции чтения и записи.
	Например: MVC (Model-View-Controller), Event Sourcing (Событийное ведение), Микросервисы, и т.д.

5. **SAGA**: 
	Паттерн использующийся для управления транзакциями, которые распределены по нескольким микросервисам.
	Он обеспечивает согласованность данных на уровне всей системы.
	
	Виды саги:
	
	1. **Оркестратор**
	Сервис, являющийся оркестратором координирует выполнение саги.
	Он знает порядок выполнения других микросервисов, и управляет этим процессом.
	
	2. **Хореография**
	Каждый сервис знает, какой шаг следует выполнить далее.
	Когда сервис завершает работу, он отправляет сообщение, которое говорит следующему сервису начинать работу.
	Это делает систему более децентрализованной, но также может привести к более сложной логике в каждом сервисе.
## ==**Идиомы:**==

Идиомы представляют собой паттерны низкого уровня. Их предметная область — реализация той или иной проблемы.

## ==**Паттерны проектирования (дизайн паттерны):**==

**Порождающие паттерны**
	(Creational Patterns): Они помогают сделать создание объектов более гибким, удобным и независимым от системы.

1) **Синглтон**

2) **Builder**

3) **Factory Method** (Фабричный метод) — является реализацией полиморфизма, то есть главный класс задается интерфейсом или абстрактным классом, а реализация определяется уже подклассами.

  
**Структурные паттерны (Structural Patterns):** 
	определяют отношения объектов для создания более крупных структур.

**Adapter** — позволяет двум разным интерфейсам работать вместе.

**Bridge** - используется для разделения абстракции от реализации, позволяя изменять их независимо друг от друга. (Например, Spring Data JPA позволяет использовать разные источники данных (MySQL, PostgreSQL и др.) без изменения кода репозиториев.)

**Фасад** - Когда вы хотите разложить подсистему на отдельные слои.  
  

**Поведенческие паттерны (Behavioral Patterns)**:
	Эти паттерны управляют взаимодействием между объектами.

1) **ChainOfResponsibility** — позволяет передавать запросы последовательно по цепочке обработчиков. Пример Spring Security FilterChain или ClassLoader

2) **Iterator** — дает возможность последовательно обходить элементы

3) **Observer** — позволяет одним объектам следить и реагировать на различнве события. Например в спринг это EventListener

---

