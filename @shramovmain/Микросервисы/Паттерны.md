![[MicroservicePatternLanguage.jpg]]

**Существует три основные разновидности паттернов:**

**Архитектурные паттерны;**

Они нужны для проектирования всей программы, а не отдельных ее элементов.

1. **API Gateway**: Центральная точка входа для клиентов. С помощью него можно обеспечить безопасность, маршрутизацию и т.д
Разновидностью этого шаблона является еще: 
**Backends for Frontends**(Определяет отдельный шлюз для каждого типа клиентов)

2. **Service Registry & Discovery**: Позволяет организовать взаимодействия между микросервисами. Основная реализация - Eureka, которая позволяет приложениям находить сервисы регистрировать их в специальный реестр **ServiceRegistry**. То есть клиенты в последствии могут обращаться к этим сервисам используя их имена, вместо того чтобы знать их конкретные адреса. @EnableEurekaService(интеграция со спрингом). Тут же можно выделить паттерны регистрации такие как - **SelfRegistration**(При такой регистрации каждый сервис сам несет ответственность за регистрацию, обновление своих сервисов), **3rdPartyRegistration**(Регистрация с помощью сторонего приложение), **Server-Side Service discovery** (через API Gateway к реестру)

3. **CircuitBreaker:** Проблема: Сбой данных одного сервиса потенциально может распространиться на другие сервисы. То есть один сервис вызывает другой сервис,  а другой сервис недоступен, вызывающий сервис находится в ожидании, тем самым тоже становится недоступным. Решение: Клиент должен вызывать другой сервис через прокси сервер, который мониторит вызовы к внешнему сервису, и при обнаружении слишком большого кол-ва неудачных попыток временно отключает вызов, предотвращая падения всей системы, то есть он временно прерывает запросы к сбойному сервису. Реализация этого паттерна является Hystrix. То есть она предоставляет HystrixCommand для обертывания вызовов к сервису. run() - этого класса содержит логику вызова, которую нам нужно защитить, также методы execute(), queue()

4. CQRS

Например: MVC (Model-View-Controller), Event Sourcing (Событийное ведение), Микросервисы, и т.д.

**Идиомы**;

Идиомы представляют собой паттерны низкого уровня. Их предметная область — реализация той или иной проблемы.


**Паттерны проектирования (дизайн паттерны):**

Порождающие паттерны (Creational Patterns): Они помогают сделать создание объектов более гибким, удобным и независимым от системы.

1) **Синглтон**

2) **Builder**

3) **Factory Method** (Фабричный метод) — является реализацией полиморфизма, то есть главный класс задается интерфейсом или абстрактным классом, а реализация определяется уже подклассами.

  
**Структурные паттерны (Structural Patterns):** определяют отношения объектов для создания более крупных структур.

**Adapter** — позволяет двум разным интерфейсам работать вместе.

**Bridge** - используется для разделения абстракции от реализации, позволяя изменять их независимо друг от друга. (Например, Spring Data JPA позволяет использовать разные источники данных (MySQL, PostgreSQL и др.) без изменения кода репозиториев.)

**Фасад** - Когда вы хотите разложить подсистему на отдельные слои.  
  

**Поведенческие паттерны (Behavioral Patterns)**: Эти паттерны управляют взаимодействием между объектами.

1) **ChainOfResponsibility** — позволяет передавать запросы последовательно по цепочке обработчиков. Пример Spring Security FilterChain или ClassLoader

2) **Iterator** — дает возможность последовательно обходить элементы

3) **Observer** — позволяет одним объектам следить и реагировать на различнве события. Например в спринг это EventListener

  
  

**SAGA**

У нас есть сложная транзакция, которая включает несколько этапов, выполняемых в разных микросервисах. Каждый этап вносит изменения. Если в каком-то микросервисе происходит ошибка на одном из этапов, то это может привести к потере данных.

Виды саги:

1) **Оркестратор**.Оркестратор отправляет запрос на выполнение каждого шага и ждет ответ(подтверждение) после чего вызывает другой сервис. Если происходит сбой применяются компекационные действия.

2) **Хореография**. Используется такая, событийная модель, где мы не ожидаем ответ, то есть мы отправляем событие и если кто то заинтересован, он воспользуется этим событием. В случае неудачи, сервис генерирует это событие неудачи, и тот микросервис который отправил событие отслеживает это событие неудачи, и выполнит откат


---

Ваше описание паттернов очень точное и подробное. Я добавлю некоторые дополнения и уточнения:

**Архитектурные паттерны:**

1. **API Gateway**: Это не только центральная точка входа для клиентов, но и слой абстракции, который скрывает внутренние детали микросервисов. Он также может выполнять функции, такие как балансировка нагрузки, кеширование, доступ к данным и авторизация.
    
2. **Service Registry & Discovery**: Важно отметить, что Eureka - это одна из реализаций этого паттерна, но есть и другие, такие как Consul или Zookeeper.
    
3. **CircuitBreaker**: Hystrix - это одна из реализаций этого паттерна, но есть и другие, такие как Resilience4j или Spring Retry.
    
4. **CQRS (Command Query Responsibility Segregation)**: Этот паттерн предполагает разделение операций чтения и записи, что может улучшить производительность и масштабируемость системы.
    

**Паттерны проектирования:**

1. **Синглтон**:
Важно помнить, что использование этого паттерна может привести к проблемам в многопоточной среде, если он не реализован правильно.
    
2. **Builder**: Этот паттерн особенно полезен, когда у объекта много параметров конструктора, и вы хотите сделать процесс создания объекта более понятным и контролируемым.
    
3. **Factory Method**: Этот паттерн обеспечивает гибкость, позволяя подклассам определять, какие конкретные классы будут создаваться.

**Структурные паттерны:**

**Adapter**: Этот паттерн также может быть полезен для обеспечения обратной совместимости между новыми и старыми интерфейсами.

**Bridge**: Этот паттерн позволяет изменять абстракцию и реализацию независимо, что упрощает код и делает его более гибким.

**Фасад**: Этот паттерн обеспечивает упрощенный интерфейс к сложной подсистеме, что улучшает читаемость и поддерживаемость кода.

**Поведенческие паттерны:**

1. **ChainOfResponsibility**: Этот паттерн позволяет уменьшить связность системы, делая ее более гибкой и легкой для изменений.
    
2. **Iterator**: Этот паттерн обеспечивает унифицированный способ обхода различных структур данных.
    
3. **Observer**: Этот паттерн обеспечивает эффективное и надежное взаимодействие между объектами.
    

**SAGA**: Этот паттерн используется для управления транзакциями, которые распределены по нескольким микросервисам. Он обеспечивает согласованность данных на уровне всей системы. Виды саги:

1. **Оркестратор**: В этом подходе один сервис (оркестратор) координирует выполнение саги. Он знает порядок выполнения шагов и обрабатывает компенсационные транзакции при необходимости.
    
2. **Хореография**: В этом подходе каждый сервис знает, какой шаг следует выполнить далее. Это делает систему более децентрализованной, но также может привести к более сложной логике в каждом сервисе.
    
