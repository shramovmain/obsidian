Процесс автоматического восстановления неиспользуемой памяти во время выполнения путём уничтожения мусорных объектов.

>**Epsilon GC**

- Вообще не собирает мусор
- Выделяет память под новые объекты, пока объём кучи не будет превышен, затем выбрасывает ошибку OutOfMemoryError: Heap Space.

>**Serial GC**

- Однопоточный с минимальным потреблением ресурсов.
- В начале каждой сборки происходит Stop-The-World пауза и отключатся только после окончания сборки.

**Малая сборка:**
	В несколько этапов "уничтожением и копированием" переносит объекты:
	Edan -> S0 -> S1 -> Tenured

**Большая сборка** (совмещенная с малой сборкой):
	Когда в Tenured заканчивается место, проходит Mark-Sweep-Compact (Живые объекты помечаются, неиспользуемые удаляются, оставшиеся сжимаются)

>**Parallel GC**

- Идентичен Serial GC, кроме: Малая и Большая сборки поддерживают многопоточность.

>**Concurrent Mark Sweep (CMS) GC:**

- Идентичен Parallel GC, кроме:
	- В Tenured объекты удаляются, но не уплотняются.
	- Малая и Большая сборка происходят раздельно.
	- Пометки и удаление происходит в фоне, не дожидаясь заполнения Tenured/
	- Допускает наличие "плавающего мусора" (неиспользуемых объектов, не найденных в процессе сборки, которые будут убраны в следующих сборках)
		Это происходит из-за применяющегося подхода Snupshot-At-The-Beginning (делается виртуальный снимок кучи до начала маркировки, и пока GC работает, все объекты, которые были живыми в начале маркировки, остаются живыми на протяжении всего цикла)

**Большая сборка:**
	1) Stop-The-World пауза
	2) Пометка всех объектов напрямую из доступных корней
	3) Возобновление работы приложения, параллельный поиск всех живых объектов из п. 2.
	4) Stop-The-World пауза
	5) Поиск упущенных объектов
	6) Возобновление работы приложения, удаление мусора в фоновом режиме

>**Garbage First (G1) GC**

- Сборщик по умолчанию с Java 9.
- Память разбита на равные небольшие области (не более 2048)
	- Области памяти могут менять свой статус (из Eden в Tenured), если в них окажется большое кол-во Tenured объектов.
- Для получения живых объектов использует алгоритм Snupshot-At-The-Beginning.
- Изначально позиционировался, как сборщик для куч 4gb +.

**Малая сборка:**
	Аналогичная Parallel GC и CMC GC, кроме:
		Сборка происходит не на всём поколении, а на выбранных GC регионах.

**Большая сборка** (совмещенная с малой сборкой):
	Цикл пометки:
		1) Stop-The-World пауза, пометка корней с использованием информации, полученной из малых сборок.
		2) Возобновление работы приложения , пометка всех живых объектов в куче несколькими потоками параллельно.
		3) Stop-The-World пауза, дополнительный поиск неучтённых ранее живых объектов.
		4) Очистка вспомогательных структур учёта ссылок на объекты и поиск пустых регионов, которые можно использовать для размещения новых объектов.
		После цикла пометки:
			Во время проведения малых сборок, к ним добавляется несколько регионов старшего поколения до тех пор, пока размер поколения не достигнет желаемого, при этом, не допуская превышение максимального времени сборки.
		После достижения этого порога, G1 снова переходит к малым сборкам.

>**ZGS GC**

- Stop-The-World паузы менее миллисекунды
- Поддержка куч до 16 ТБ.
- Использует цветные указатель с дополнительными метаданными (цветами) объекта, помимо обычного адреса объекта.
	Комбинация этих цветов определяет состояние указателя, которое при описании ZGC GS называется его цветом.
- Использует концепцию виртуальной памяти (разные страницы виртуальной памяти могут указывать на одну и ту же страницу физической памяти).
- Использует **Барьеры**
	Например:
		При обращении к объекту с маркером на удаление, GC может Main-поток сначала перенести его в новые регион, и только затем обратиться.
- Работает с Java 15.

**Этапы сборки:**
	 Цикл пометки:
		 1) Небольшая в начале для поиска объектов.
		 2) Конкурентный поиск (многопоточный) выживших объектов.
		 3) Небольшая пауза в конце для поиска упущенных объектов.
	Перемещение объектов по памяти:
		1) Конкурентная (многопоточная) подготовка к перемещению.
		2) Небольшая пауза перед началом перемещения.
		3) Конкурентное (многопоточное) перемещение



>**Shenandoah GC**

- Главный конкурент ZGC, также относится к **Ultra-Low-Latency** GC
- В отличии от ZGC добавляет Указатели Брукса, которые хранят флаги не в указателях, в непосредственно в самом объекте.
	Например: 
		Указатель перенаправления, который указывает на то, что объект имеет копию в новом месте.
- Куча разбита на регионы, которые:
	- Могут размещать живые объекты и не подлежать очистке.
	- Могут размещать живые объекты и подлежать очистке.
	- Могут быть забронированы под перемещение живых объектов из очищаемых регионов.
	- Не использоваться.
- Входит в состав OpenJDK начиная с 12 версии.
