![[MicroservicePatternLanguage.jpg]]

**Существует три основные разновидности паттернов:**

**Архитектурные паттерны;**

Они нужны для проектирования всей программы, а не отдельных ее элементов.

1. **API Gateway**: Центральная точка входа для клиентов. С помощью него можно обеспечить безопасность, маршрутизацию и т.д
Разновидностью этого шаблона является еще: 
**Backends for Frontends**(Определяет отдельный шлюз для каждого типа клиентов)

2. **Service Registry & Discovery**: Позволяет организовать взаимодействия между микросервисами. Основная реализация - Eureka, которая позволяет приложениям находить сервисы регистрировать их в специальный реестр **ServiceRegistry**. То есть клиенты в последствии могут обращаться к этим сервисам используя их имена, вместо того чтобы знать их конкретные адреса. @EnableEurekaService(интеграция со спрингом). Тут же можно выделить паттерны регистрации такие как - **SelfRegistration**(При такой регистрации каждый сервис сам несет ответственность за регистрацию, обновление своих сервисов), **3rdPartyRegistration**(Регистрация с помощью сторонего приложение), **Server-Side Service discovery** (через API Gateway к реестру)

3. **CircuitBreaker:** Проблема: Сбой данных одного сервиса потенциально может распространиться на другие сервисы. То есть один сервис вызывает другой сервис,  а другой сервис недоступен, вызывающий сервис находится в ожидании, тем самым тоже становится недоступным. Решение: Клиент должен вызывать другой сервис через прокси сервер, который мониторит вызовы к внешнему сервису, и при обнаружении слишком большого кол-ва неудачных попыток временно отключает вызов, предотвращая падения всей системы, то есть он временно прерывает запросы к сбойному сервису. Реализация этого паттерна является Hystrix. То есть она предоставляет HystrixCommand для обертывания вызовов к сервису. run() - этого класса содержит логику вызова, которую нам нужно защитить, также методы execute(), queue()

4. CQRS

Например: MVC (Model-View-Controller), Event Sourcing (Событийное ведение), Микросервисы, и т.д.

**Идиомы**;

Идиомы представляют собой паттерны низкого уровня. Их предметная область — реализация той или иной проблемы.



**Паттерны проектирования (дизайн паттерны):**

Порождающие паттерны (Creational Patterns): Они помогают сделать создание объектов более гибким, удобным и независимым от системы.

1) **Синглтон**

2) **Builder**

3) **Factory Method** (Фабричный метод) — является реализацией полиморфизма, то есть главный класс задается интерфейсом или абстрактным классом, а реализация определяется уже подклассами.

  
**Структурные паттерны (Structural Patterns):** определяют отношения объектов для создания более крупных структур.

**Adapter** — позволяет двум разным интерфейсам работать вместе.

**Bridge** - используется для разделения абстракции от реализации, позволяя изменять их независимо друг от друга. (Например, Spring Data JPA позволяет использовать разные источники данных (MySQL, PostgreSQL и др.) без изменения кода репозиториев.)

**Фасад** - Когда вы хотите разложить подсистему на отдельные слои.  
  
  

**Поведенческие паттерны (Behavioral Patterns)**: Эти паттерны управляют взаимодействием между объектами.

1) **ChainOfResponsibility** — позволяет передавать запросы последовательно по цепочке обработчиков. Пример Spring Security FilterChain или ClassLoader

2) **Iterator** — дает возможность последовательно обходить элементы

3) **Observer** — позволяет одним объектам следить и реагировать на различнве события. Например в спринг это EventListener

  
  

**SAGA**

У нас есть сложная транзакция, которая включает несколько этапов, выполняемых в разных микросервисах. Каждый этап вносит изменения. Если в каком-то микросервисе происходит ошибка на одном из этапов, то это может привести к потере данных.

Виды саги:

1) **Оркестратор**.Оркестратор отправляет запрос на выполнение каждого шага и ждет ответ(подтверждение) после чего вызывает другой сервис. Если происходит сбой применяются компекационные действия.

2) **Хореография**. Используется такая, событийная модель, где мы не ожидаем ответ, то есть мы отправляем событие и если кто то заинтересован, он воспользуется этим событием. В случае неудачи, сервис генерирует это событие неудачи, и тот микросервис который отправил событие отслеживает это событие неудачи, и выполнит откат


**Принципы SOLID**

S - **Принцип единственной ответственности (Single Responsibility Principle)**: Каждый класс должен иметь только одну задачу. То есть не должно быть кучи лишней логики не связанной с этим классом

O - **Принцип открытости/закрытости (Open/Closed Principle)**: Классы должны быть открыты для расширения, но закрыты для изменения.

L - **Принцип подстановки Барбары Лисков (Liskov Substitution Principle)**: Подклассы не должны заменять функционал базового класса.

I - **Принцип разделения интерфейса (Interface Segregation Principle):** "Много специализированных интерфейсов лучше, чем один универсальный".

D - **Принцип инверсии зависимостей (Dependency Inversion Principle):** "Зависимость на Абстракциях. Нет зависимости на что-то конкретное".